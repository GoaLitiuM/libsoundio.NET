//----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace libsoundio.NET
{
    /// <summary>
    /// <para>See also ::soundio_strerror</para>
    /// </summary>
    public enum SoundIoError
    {
        SoundIoErrorNone = 0,
        /// <summary>Out of memory.</summary>
        SoundIoErrorNoMem = 1,
        /// <summary>The backend does not appear to be active or running.</summary>
        SoundIoErrorInitAudioBackend = 2,
        /// <summary>A system resource other than memory was not available.</summary>
        SoundIoErrorSystemResources = 3,
        /// <summary>Attempted to open a device and failed.</summary>
        SoundIoErrorOpeningDevice = 4,
        /// <summary>Attempted to open a device and failed.</summary>
        SoundIoErrorNoSuchDevice = 5,
        /// <summary>The programmer did not comply with the API.</summary>
        SoundIoErrorInvalid = 6,
        /// <summary>libsoundio was compiled without support for that backend.</summary>
        SoundIoErrorBackendUnavailable = 7,
        /// <summary>An open stream had an error that can only be recovered from by destroying the stream and creating it again.</summary>
        SoundIoErrorStreaming = 8,
        /// <summary>Attempted to use a device with parameters it cannot support.</summary>
        SoundIoErrorIncompatibleDevice = 9,
        /// <summary>When JACK returns `JackNoSuchClient`</summary>
        SoundIoErrorNoSuchClient = 10,
        /// <summary>Attempted to use parameters that the backend cannot support.</summary>
        SoundIoErrorIncompatibleBackend = 11,
        /// <summary>Backend server shutdown or became inactive.</summary>
        SoundIoErrorBackendDisconnected = 12,
        /// <summary>Backend server shutdown or became inactive.</summary>
        SoundIoErrorInterrupted = 13,
        /// <summary>Buffer underrun occurred.</summary>
        SoundIoErrorUnderflow = 14,
        /// <summary>Unable to convert to or from UTF-8 to the native string format.</summary>
        SoundIoErrorEncodingString = 15
    }

    /// <summary>
    /// <para>Specifies where a channel is physically located.</para>
    /// </summary>
    public enum SoundIoChannelId
    {
        SoundIoChannelIdInvalid = 0,
        /// <summary>First of the more commonly supported ids.</summary>
        SoundIoChannelIdFrontLeft = 1,
        SoundIoChannelIdFrontRight = 2,
        SoundIoChannelIdFrontCenter = 3,
        SoundIoChannelIdLfe = 4,
        SoundIoChannelIdBackLeft = 5,
        SoundIoChannelIdBackRight = 6,
        SoundIoChannelIdFrontLeftCenter = 7,
        SoundIoChannelIdFrontRightCenter = 8,
        SoundIoChannelIdBackCenter = 9,
        SoundIoChannelIdSideLeft = 10,
        SoundIoChannelIdSideRight = 11,
        SoundIoChannelIdTopCenter = 12,
        SoundIoChannelIdTopFrontLeft = 13,
        SoundIoChannelIdTopFrontCenter = 14,
        SoundIoChannelIdTopFrontRight = 15,
        SoundIoChannelIdTopBackLeft = 16,
        SoundIoChannelIdTopBackCenter = 17,
        /// <summary>Last of the more commonly supported ids.</summary>
        SoundIoChannelIdTopBackRight = 18,
        /// <summary>First of the less commonly supported ids.</summary>
        SoundIoChannelIdBackLeftCenter = 19,
        SoundIoChannelIdBackRightCenter = 20,
        SoundIoChannelIdFrontLeftWide = 21,
        SoundIoChannelIdFrontRightWide = 22,
        SoundIoChannelIdFrontLeftHigh = 23,
        SoundIoChannelIdFrontCenterHigh = 24,
        SoundIoChannelIdFrontRightHigh = 25,
        SoundIoChannelIdTopFrontLeftCenter = 26,
        SoundIoChannelIdTopFrontRightCenter = 27,
        SoundIoChannelIdTopSideLeft = 28,
        SoundIoChannelIdTopSideRight = 29,
        SoundIoChannelIdLeftLfe = 30,
        SoundIoChannelIdRightLfe = 31,
        SoundIoChannelIdLfe2 = 32,
        SoundIoChannelIdBottomCenter = 33,
        SoundIoChannelIdBottomLeftCenter = 34,
        SoundIoChannelIdBottomRightCenter = 35,
        /// <summary>Mid/side recording</summary>
        SoundIoChannelIdMsMid = 36,
        /// <summary>Mid/side recording</summary>
        SoundIoChannelIdMsSide = 37,
        /// <summary>first order ambisonic channels</summary>
        SoundIoChannelIdAmbisonicW = 38,
        /// <summary>first order ambisonic channels</summary>
        SoundIoChannelIdAmbisonicX = 39,
        /// <summary>first order ambisonic channels</summary>
        SoundIoChannelIdAmbisonicY = 40,
        /// <summary>first order ambisonic channels</summary>
        SoundIoChannelIdAmbisonicZ = 41,
        /// <summary>X-Y Recording</summary>
        SoundIoChannelIdXyX = 42,
        /// <summary>X-Y Recording</summary>
        SoundIoChannelIdXyY = 43,
        /// <summary>First of the "other" channel ids</summary>
        SoundIoChannelIdHeadphonesLeft = 44,
        SoundIoChannelIdHeadphonesRight = 45,
        SoundIoChannelIdClickTrack = 46,
        SoundIoChannelIdForeignLanguage = 47,
        SoundIoChannelIdHearingImpaired = 48,
        SoundIoChannelIdNarration = 49,
        SoundIoChannelIdHaptic = 50,
        /// <summary>Last of the "other" channel ids</summary>
        SoundIoChannelIdDialogCentricMix = 51,
        SoundIoChannelIdAux = 52,
        SoundIoChannelIdAux0 = 53,
        SoundIoChannelIdAux1 = 54,
        SoundIoChannelIdAux2 = 55,
        SoundIoChannelIdAux3 = 56,
        SoundIoChannelIdAux4 = 57,
        SoundIoChannelIdAux5 = 58,
        SoundIoChannelIdAux6 = 59,
        SoundIoChannelIdAux7 = 60,
        SoundIoChannelIdAux8 = 61,
        SoundIoChannelIdAux9 = 62,
        SoundIoChannelIdAux10 = 63,
        SoundIoChannelIdAux11 = 64,
        SoundIoChannelIdAux12 = 65,
        SoundIoChannelIdAux13 = 66,
        SoundIoChannelIdAux14 = 67,
        SoundIoChannelIdAux15 = 68
    }

    /// <summary>
    /// <para>Built-in channel layouts for convenience.</para>
    /// </summary>
    public enum SoundIoChannelLayoutId
    {
        SoundIoChannelLayoutIdMono = 0,
        SoundIoChannelLayoutIdStereo = 1,
        SoundIoChannelLayoutId2Point1 = 2,
        SoundIoChannelLayoutId3Point0 = 3,
        SoundIoChannelLayoutId3Point0Back = 4,
        SoundIoChannelLayoutId3Point1 = 5,
        SoundIoChannelLayoutId4Point0 = 6,
        SoundIoChannelLayoutIdQuad = 7,
        SoundIoChannelLayoutIdQuadSide = 8,
        SoundIoChannelLayoutId4Point1 = 9,
        SoundIoChannelLayoutId5Point0Back = 10,
        SoundIoChannelLayoutId5Point0Side = 11,
        SoundIoChannelLayoutId5Point1 = 12,
        SoundIoChannelLayoutId5Point1Back = 13,
        SoundIoChannelLayoutId6Point0Side = 14,
        SoundIoChannelLayoutId6Point0Front = 15,
        SoundIoChannelLayoutIdHexagonal = 16,
        SoundIoChannelLayoutId6Point1 = 17,
        SoundIoChannelLayoutId6Point1Back = 18,
        SoundIoChannelLayoutId6Point1Front = 19,
        SoundIoChannelLayoutId7Point0 = 20,
        SoundIoChannelLayoutId7Point0Front = 21,
        SoundIoChannelLayoutId7Point1 = 22,
        SoundIoChannelLayoutId7Point1Wide = 23,
        SoundIoChannelLayoutId7Point1WideBack = 24,
        SoundIoChannelLayoutIdOctagonal = 25
    }

    public enum SoundIoBackend
    {
        SoundIoBackendNone = 0,
        SoundIoBackendJack = 1,
        SoundIoBackendPulseAudio = 2,
        SoundIoBackendAlsa = 3,
        SoundIoBackendCoreAudio = 4,
        SoundIoBackendWasapi = 5,
        SoundIoBackendDummy = 6
    }

    public enum SoundIoDeviceAim
    {
        /// <summary>capture / recording</summary>
        SoundIoDeviceAimInput = 0,
        /// <summary>playback</summary>
        SoundIoDeviceAimOutput = 1
    }

    /// <summary>
    /// <para>For your convenience, Native Endian and Foreign Endian constants are defined</para>
    /// <para>which point to the respective SoundIoFormat values.</para>
    /// </summary>
    public enum SoundIoFormat
    {
        SoundIoFormatInvalid = 0,
        /// <summary>Signed 8 bit</summary>
        SoundIoFormatS8 = 1,
        /// <summary>Unsigned 8 bit</summary>
        SoundIoFormatU8 = 2,
        /// <summary>Signed 16 bit Little Endian</summary>
        SoundIoFormatS16LE = 3,
        /// <summary>Signed 16 bit Big Endian</summary>
        SoundIoFormatS16BE = 4,
        /// <summary>Unsigned 16 bit Little Endian</summary>
        SoundIoFormatU16LE = 5,
        /// <summary>Unsigned 16 bit Little Endian</summary>
        SoundIoFormatU16BE = 6,
        /// <summary>Signed 24 bit Little Endian using low three bytes in 32-bit word</summary>
        SoundIoFormatS24LE = 7,
        /// <summary>Signed 24 bit Big Endian using low three bytes in 32-bit word</summary>
        SoundIoFormatS24BE = 8,
        /// <summary>Unsigned 24 bit Little Endian using low three bytes in 32-bit word</summary>
        SoundIoFormatU24LE = 9,
        /// <summary>Unsigned 24 bit Big Endian using low three bytes in 32-bit word</summary>
        SoundIoFormatU24BE = 10,
        /// <summary>Signed 32 bit Little Endian</summary>
        SoundIoFormatS32LE = 11,
        /// <summary>Signed 32 bit Big Endian</summary>
        SoundIoFormatS32BE = 12,
        /// <summary>Unsigned 32 bit Little Endian</summary>
        SoundIoFormatU32LE = 13,
        /// <summary>Unsigned 32 bit Big Endian</summary>
        SoundIoFormatU32BE = 14,
        /// <summary>Float 32 bit Little Endian, Range -1.0 to 1.0</summary>
        SoundIoFormatFloat32LE = 15,
        /// <summary>Float 32 bit Big Endian, Range -1.0 to 1.0</summary>
        SoundIoFormatFloat32BE = 16,
        /// <summary>Float 64 bit Little Endian, Range -1.0 to 1.0</summary>
        SoundIoFormatFloat64LE = 17,
        /// <summary>Float 64 bit Big Endian, Range -1.0 to 1.0</summary>
        SoundIoFormatFloat64BE = 18
    }

    /// <summary>
    /// <para>The size of this struct is OK to use.</para>
    /// </summary>
    public unsafe partial class SoundIoChannelLayout : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 104)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr name;

            [FieldOffset(4)]
            public int channel_count;

            [FieldOffset(8)]
            public fixed SoundIoChannelId channels[24];

            [FieldOffset(12)]
            public SoundIoChannelId __dummy_channels_1;

            [FieldOffset(16)]
            public SoundIoChannelId __dummy_channels_2;

            [FieldOffset(20)]
            public SoundIoChannelId __dummy_channels_3;

            [FieldOffset(24)]
            public SoundIoChannelId __dummy_channels_4;

            [FieldOffset(28)]
            public SoundIoChannelId __dummy_channels_5;

            [FieldOffset(32)]
            public SoundIoChannelId __dummy_channels_6;

            [FieldOffset(36)]
            public SoundIoChannelId __dummy_channels_7;

            [FieldOffset(40)]
            public SoundIoChannelId __dummy_channels_8;

            [FieldOffset(44)]
            public SoundIoChannelId __dummy_channels_9;

            [FieldOffset(48)]
            public SoundIoChannelId __dummy_channels_10;

            [FieldOffset(52)]
            public SoundIoChannelId __dummy_channels_11;

            [FieldOffset(56)]
            public SoundIoChannelId __dummy_channels_12;

            [FieldOffset(60)]
            public SoundIoChannelId __dummy_channels_13;

            [FieldOffset(64)]
            public SoundIoChannelId __dummy_channels_14;

            [FieldOffset(68)]
            public SoundIoChannelId __dummy_channels_15;

            [FieldOffset(72)]
            public SoundIoChannelId __dummy_channels_16;

            [FieldOffset(76)]
            public SoundIoChannelId __dummy_channels_17;

            [FieldOffset(80)]
            public SoundIoChannelId __dummy_channels_18;

            [FieldOffset(84)]
            public SoundIoChannelId __dummy_channels_19;

            [FieldOffset(88)]
            public SoundIoChannelId __dummy_channels_20;

            [FieldOffset(92)]
            public SoundIoChannelId __dummy_channels_21;

            [FieldOffset(96)]
            public SoundIoChannelId __dummy_channels_22;

            [FieldOffset(100)]
            public SoundIoChannelId __dummy_channels_23;
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SoundIoChannelLayout> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SoundIoChannelLayout>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static SoundIoChannelLayout __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new SoundIoChannelLayout(native.ToPointer(), skipVTables);
        }

        public static SoundIoChannelLayout __CreateInstance(SoundIoChannelLayout.Internal native, bool skipVTables = false)
        {
            return new SoundIoChannelLayout(native, skipVTables);
        }

        private static void* __CopyValue(SoundIoChannelLayout.Internal native)
        {
            var ret = Marshal.AllocHGlobal(104);
            *(SoundIoChannelLayout.Internal*) ret = native;
            return ret.ToPointer();
        }

        private SoundIoChannelLayout(SoundIoChannelLayout.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SoundIoChannelLayout(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            SoundIoChannelLayout __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public string name
        {
            get
            {
                return Marshal.PtrToStringAnsi(((Internal*) __Instance)->name);
            }

            set
            {
                ((Internal*) __Instance)->name = (global::System.IntPtr) Marshal.StringToHGlobalAnsi(value);
            }
        }

        public int channel_count
        {
            get
            {
                return ((Internal*) __Instance)->channel_count;
            }

            set
            {
                ((Internal*) __Instance)->channel_count = value;
            }
        }
    }

    /// <summary>
    /// <para>The size of this struct is OK to use.</para>
    /// </summary>
    public unsafe partial class SoundIoSampleRateRange : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public int min;

            [FieldOffset(4)]
            public int max;
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SoundIoSampleRateRange> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SoundIoSampleRateRange>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static SoundIoSampleRateRange __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new SoundIoSampleRateRange(native.ToPointer(), skipVTables);
        }

        public static SoundIoSampleRateRange __CreateInstance(SoundIoSampleRateRange.Internal native, bool skipVTables = false)
        {
            return new SoundIoSampleRateRange(native, skipVTables);
        }

        private static void* __CopyValue(SoundIoSampleRateRange.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            *(SoundIoSampleRateRange.Internal*) ret = native;
            return ret.ToPointer();
        }

        private SoundIoSampleRateRange(SoundIoSampleRateRange.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SoundIoSampleRateRange(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            SoundIoSampleRateRange __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public int min
        {
            get
            {
                return ((Internal*) __Instance)->min;
            }

            set
            {
                ((Internal*) __Instance)->min = value;
            }
        }

        public int max
        {
            get
            {
                return ((Internal*) __Instance)->max;
            }

            set
            {
                ((Internal*) __Instance)->max = value;
            }
        }
    }

    /// <summary>
    /// <para>The size of this struct is OK to use.</para>
    /// </summary>
    public unsafe partial class SoundIoChannelArea : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 8)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr ptr;

            [FieldOffset(4)]
            public int step;
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SoundIoChannelArea> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SoundIoChannelArea>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static SoundIoChannelArea __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new SoundIoChannelArea(native.ToPointer(), skipVTables);
        }

        public static SoundIoChannelArea __CreateInstance(SoundIoChannelArea.Internal native, bool skipVTables = false)
        {
            return new SoundIoChannelArea(native, skipVTables);
        }

        private static void* __CopyValue(SoundIoChannelArea.Internal native)
        {
            var ret = Marshal.AllocHGlobal(8);
            *(SoundIoChannelArea.Internal*) ret = native;
            return ret.ToPointer();
        }

        private SoundIoChannelArea(SoundIoChannelArea.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SoundIoChannelArea(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            SoundIoChannelArea __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public sbyte* ptr
        {
            get
            {
                return ((Internal*) __Instance)->ptr;
            }

            set
            {
                ((Internal*) __Instance)->ptr = (global::System.IntPtr) value;
            }
        }

        public int step
        {
            get
            {
                return ((Internal*) __Instance)->step;
            }

            set
            {
                ((Internal*) __Instance)->step = value;
            }
        }
    }

    /// <summary>
    /// <para>The size of this struct is not part of the API or ABI.</para>
    /// </summary>
    public unsafe partial class SoundIo : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 36)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr userdata;

            [FieldOffset(4)]
            public global::System.IntPtr on_devices_change;

            [FieldOffset(8)]
            public global::System.IntPtr on_backend_disconnect;

            [FieldOffset(12)]
            public global::System.IntPtr on_events_signal;

            [FieldOffset(16)]
            public SoundIoBackend current_backend;

            [FieldOffset(20)]
            public global::System.IntPtr app_name;

            [FieldOffset(24)]
            public global::System.IntPtr emit_rtprio_warning;

            [FieldOffset(28)]
            public global::System.IntPtr jack_info_callback;

            [FieldOffset(32)]
            public global::System.IntPtr jack_error_callback;

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_version_string")]
            internal static extern global::System.IntPtr soundio_version_string_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_version_major")]
            internal static extern int soundio_version_major_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_version_minor")]
            internal static extern int soundio_version_minor_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_version_patch")]
            internal static extern int soundio_version_patch_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_create")]
            internal static extern global::System.IntPtr soundio_create_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_destroy")]
            internal static extern void soundio_destroy_0(global::System.IntPtr soundio);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_connect")]
            internal static extern int soundio_connect_0(global::System.IntPtr soundio);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_connect_backend")]
            internal static extern int soundio_connect_backend_0(global::System.IntPtr soundio, SoundIoBackend backend);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_disconnect")]
            internal static extern void soundio_disconnect_0(global::System.IntPtr soundio);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_strerror")]
            internal static extern global::System.IntPtr soundio_strerror_0(int error);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_backend_name")]
            internal static extern global::System.IntPtr soundio_backend_name_0(SoundIoBackend backend);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_backend_count")]
            internal static extern int soundio_backend_count_0(global::System.IntPtr soundio);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_get_backend")]
            internal static extern SoundIoBackend soundio_get_backend_0(global::System.IntPtr soundio, int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_have_backend")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool soundio_have_backend_0(SoundIoBackend backend);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_flush_events")]
            internal static extern void soundio_flush_events_0(global::System.IntPtr soundio);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_wait_events")]
            internal static extern void soundio_wait_events_0(global::System.IntPtr soundio);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_wakeup")]
            internal static extern void soundio_wakeup_0(global::System.IntPtr soundio);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_force_device_scan")]
            internal static extern void soundio_force_device_scan_0(global::System.IntPtr soundio);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_channel_layout_equal")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool soundio_channel_layout_equal_0(global::System.IntPtr a, global::System.IntPtr b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_get_channel_name")]
            internal static extern global::System.IntPtr soundio_get_channel_name_0(SoundIoChannelId id);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_parse_channel_id")]
            internal static extern SoundIoChannelId soundio_parse_channel_id_0(global::System.IntPtr str, int str_len);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_channel_layout_builtin_count")]
            internal static extern int soundio_channel_layout_builtin_count_0();

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_channel_layout_get_builtin")]
            internal static extern global::System.IntPtr soundio_channel_layout_get_builtin_0(int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_channel_layout_get_default")]
            internal static extern global::System.IntPtr soundio_channel_layout_get_default_0(int channel_count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_channel_layout_find_channel")]
            internal static extern int soundio_channel_layout_find_channel_0(global::System.IntPtr layout, SoundIoChannelId channel);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_channel_layout_detect_builtin")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool soundio_channel_layout_detect_builtin_0(global::System.IntPtr layout);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_best_matching_channel_layout")]
            internal static extern global::System.IntPtr soundio_best_matching_channel_layout_0(global::System.IntPtr preferred_layouts, int preferred_layout_count, global::System.IntPtr available_layouts, int available_layout_count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_sort_channel_layouts")]
            internal static extern void soundio_sort_channel_layouts_0(global::System.IntPtr layouts, int layout_count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_get_bytes_per_sample")]
            internal static extern int soundio_get_bytes_per_sample_0(SoundIoFormat format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_get_bytes_per_frame")]
            internal static extern int soundio_get_bytes_per_frame_0(SoundIoFormat format, int channel_count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_get_bytes_per_second")]
            internal static extern int soundio_get_bytes_per_second_0(SoundIoFormat format, int channel_count, int sample_rate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_format_string")]
            internal static extern global::System.IntPtr soundio_format_string_0(SoundIoFormat format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_input_device_count")]
            internal static extern int soundio_input_device_count_0(global::System.IntPtr soundio);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_output_device_count")]
            internal static extern int soundio_output_device_count_0(global::System.IntPtr soundio);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_get_input_device")]
            internal static extern global::System.IntPtr soundio_get_input_device_0(global::System.IntPtr soundio, int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_get_output_device")]
            internal static extern global::System.IntPtr soundio_get_output_device_0(global::System.IntPtr soundio, int index);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_default_input_device_index")]
            internal static extern int soundio_default_input_device_index_0(global::System.IntPtr soundio);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_default_output_device_index")]
            internal static extern int soundio_default_output_device_index_0(global::System.IntPtr soundio);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_device_ref")]
            internal static extern void soundio_device_ref_0(global::System.IntPtr device);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_device_unref")]
            internal static extern void soundio_device_unref_0(global::System.IntPtr device);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_device_equal")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool soundio_device_equal_0(global::System.IntPtr a, global::System.IntPtr b);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_device_sort_channel_layouts")]
            internal static extern void soundio_device_sort_channel_layouts_0(global::System.IntPtr device);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_device_supports_format")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool soundio_device_supports_format_0(global::System.IntPtr device, SoundIoFormat format);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_device_supports_layout")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool soundio_device_supports_layout_0(global::System.IntPtr device, global::System.IntPtr layout);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_device_supports_sample_rate")]
            [return: MarshalAsAttribute(UnmanagedType.I1)]
            internal static extern bool soundio_device_supports_sample_rate_0(global::System.IntPtr device, int sample_rate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_device_nearest_sample_rate")]
            internal static extern int soundio_device_nearest_sample_rate_0(global::System.IntPtr device, int sample_rate);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_outstream_create")]
            internal static extern global::System.IntPtr soundio_outstream_create_0(global::System.IntPtr device);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_outstream_destroy")]
            internal static extern void soundio_outstream_destroy_0(global::System.IntPtr outstream);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_outstream_open")]
            internal static extern int soundio_outstream_open_0(global::System.IntPtr outstream);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_outstream_start")]
            internal static extern int soundio_outstream_start_0(global::System.IntPtr outstream);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_outstream_begin_write")]
            internal static extern int soundio_outstream_begin_write_0(global::System.IntPtr outstream, global::System.IntPtr areas, int* frame_count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_outstream_end_write")]
            internal static extern int soundio_outstream_end_write_0(global::System.IntPtr outstream);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_outstream_clear_buffer")]
            internal static extern int soundio_outstream_clear_buffer_0(global::System.IntPtr outstream);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_outstream_pause")]
            internal static extern int soundio_outstream_pause_0(global::System.IntPtr outstream, bool pause);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_outstream_get_latency")]
            internal static extern int soundio_outstream_get_latency_0(global::System.IntPtr outstream, double* out_latency);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_instream_create")]
            internal static extern global::System.IntPtr soundio_instream_create_0(global::System.IntPtr device);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_instream_destroy")]
            internal static extern void soundio_instream_destroy_0(global::System.IntPtr instream);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_instream_open")]
            internal static extern int soundio_instream_open_0(global::System.IntPtr instream);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_instream_start")]
            internal static extern int soundio_instream_start_0(global::System.IntPtr instream);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_instream_begin_read")]
            internal static extern int soundio_instream_begin_read_0(global::System.IntPtr instream, global::System.IntPtr areas, int* frame_count);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_instream_end_read")]
            internal static extern int soundio_instream_end_read_0(global::System.IntPtr instream);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_instream_pause")]
            internal static extern int soundio_instream_pause_0(global::System.IntPtr instream, bool pause);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("soundio.NET", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="soundio_instream_get_latency")]
            internal static extern int soundio_instream_get_latency_0(global::System.IntPtr instream, double* out_latency);
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SoundIo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SoundIo>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static SoundIo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new SoundIo(native.ToPointer(), skipVTables);
        }

        public static SoundIo __CreateInstance(SoundIo.Internal native, bool skipVTables = false)
        {
            return new SoundIo(native, skipVTables);
        }

        private static void* __CopyValue(SoundIo.Internal native)
        {
            var ret = Marshal.AllocHGlobal(36);
            *(SoundIo.Internal*) ret = native;
            return ret.ToPointer();
        }

        private SoundIo(SoundIo.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SoundIo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            SoundIo __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        /// <summary>
        /// <para>See also ::soundio_version_major, ::soundio_version_minor, ::soundio_version_patch</para>
        /// </summary>
        public static string soundio_version_string()
        {
            var __ret = Internal.soundio_version_string_0();
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        /// <para>See also ::soundio_version_string, ::soundio_version_minor, ::soundio_version_patch</para>
        /// </summary>
        public static int soundio_version_major()
        {
            var __ret = Internal.soundio_version_major_0();
            return __ret;
        }

        /// <summary>
        /// <para>See also ::soundio_version_major, ::soundio_version_string, ::soundio_version_patch</para>
        /// </summary>
        public static int soundio_version_minor()
        {
            var __ret = Internal.soundio_version_minor_0();
            return __ret;
        }

        /// <summary>
        /// <para>See also ::soundio_version_major, ::soundio_version_minor, ::soundio_version_string</para>
        /// </summary>
        public static int soundio_version_patch()
        {
            var __ret = Internal.soundio_version_patch_0();
            return __ret;
        }

        /// <summary>
        /// <para>Create a SoundIo context. You may create multiple instances of this to</para>
        /// <para>connect to multiple backends. Sets all fields to defaults.</para>
        /// <para>Returns `NULL` if and only if memory could not be allocated.</para>
        /// <para>See also ::soundio_destroy</para>
        /// </summary>
        public static SoundIo soundio_create()
        {
            var __ret = Internal.soundio_create_0();
            SoundIo __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (SoundIo.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (SoundIo) SoundIo.NativeToManagedMap[__ret];
            else __result0 = SoundIo.__CreateInstance(__ret);
            return __result0;
        }

        public static void soundio_destroy(SoundIo soundio)
        {
            var __arg0 = ReferenceEquals(soundio, null) ? global::System.IntPtr.Zero : soundio.__Instance;
            Internal.soundio_destroy_0(__arg0);
        }

        /// <summary>
        /// <para>Tries ::soundio_connect_backend on all available backends in order.</para>
        /// <para>Possible errors:</para>
        /// <para>* #SoundIoErrorInvalid - already connected</para>
        /// <para>* #SoundIoErrorNoMem</para>
        /// <para>* #SoundIoErrorSystemResources</para>
        /// <para>* #SoundIoErrorNoSuchClient - when JACK returns `JackNoSuchClient`</para>
        /// <para>See also ::soundio_disconnect</para>
        /// </summary>
        public static int soundio_connect(SoundIo soundio)
        {
            var __arg0 = ReferenceEquals(soundio, null) ? global::System.IntPtr.Zero : soundio.__Instance;
            var __ret = Internal.soundio_connect_0(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Instead of calling ::soundio_connect you may call this function to try a</para>
        /// <para>specific backend.</para>
        /// <para>Possible errors:</para>
        /// <para>* #SoundIoErrorInvalid - already connected or invalid backend parameter</para>
        /// <para>* #SoundIoErrorNoMem</para>
        /// <para>* #SoundIoErrorBackendUnavailable - backend was not compiled in</para>
        /// <para>* #SoundIoErrorSystemResources</para>
        /// <para>* #SoundIoErrorNoSuchClient - when JACK returns `JackNoSuchClient`</para>
        /// <para>* #SoundIoErrorInitAudioBackend - requested `backend` is not active</para>
        /// <para>* #SoundIoErrorBackendDisconnected - backend disconnected while connecting</para>
        /// <para>See also ::soundio_disconnect</para>
        /// </summary>
        public static int soundio_connect_backend(SoundIo soundio, SoundIoBackend backend)
        {
            var __arg0 = ReferenceEquals(soundio, null) ? global::System.IntPtr.Zero : soundio.__Instance;
            var __arg1 = backend;
            var __ret = Internal.soundio_connect_backend_0(__arg0, __arg1);
            return __ret;
        }

        public static void soundio_disconnect(SoundIo soundio)
        {
            var __arg0 = ReferenceEquals(soundio, null) ? global::System.IntPtr.Zero : soundio.__Instance;
            Internal.soundio_disconnect_0(__arg0);
        }

        /// <summary>
        /// <para>Get a string representation of a #SoundIoError</para>
        /// </summary>
        public static string soundio_strerror(int error)
        {
            var __ret = Internal.soundio_strerror_0(error);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        /// <para>Get a string representation of a #SoundIoBackend</para>
        /// </summary>
        public static string soundio_backend_name(SoundIoBackend backend)
        {
            var __arg0 = backend;
            var __ret = Internal.soundio_backend_name_0(__arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        /// <para>Returns the number of available backends.</para>
        /// </summary>
        public static int soundio_backend_count(SoundIo soundio)
        {
            var __arg0 = ReferenceEquals(soundio, null) ? global::System.IntPtr.Zero : soundio.__Instance;
            var __ret = Internal.soundio_backend_count_0(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>get the available backend at the specified index</para>
        /// <para>(0 </para>
        /// <para>&lt;</para>
        /// <para>= index </para>
        /// <para>&lt;</para>
        /// <para>::soundio_backend_count)</para>
        /// </summary>
        public static SoundIoBackend soundio_get_backend(SoundIo soundio, int index)
        {
            var __arg0 = ReferenceEquals(soundio, null) ? global::System.IntPtr.Zero : soundio.__Instance;
            var __ret = Internal.soundio_get_backend_0(__arg0, index);
            return __ret;
        }

        /// <summary>
        /// <para>Returns whether libsoundio was compiled with backend.</para>
        /// </summary>
        public static bool soundio_have_backend(SoundIoBackend backend)
        {
            var __arg0 = backend;
            var __ret = Internal.soundio_have_backend_0(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Atomically update information for all connected devices. Note that calling</para>
        /// <para>this function merely flips a pointer; the actual work of collecting device</para>
        /// <para>information is done elsewhere. It is performant to call this function many</para>
        /// <para>times per second.</para>
        /// </summary>
        /// <remarks>
        /// <para>When you call this, the following callbacks might be called:</para>
        /// <para>* SoundIo::on_devices_change</para>
        /// <para>* SoundIo::on_backend_disconnect</para>
        /// <para>This is the only time those callbacks can be called.</para>
        /// <para>This must be called from the same thread as the thread in which you call</para>
        /// <para>these functions:</para>
        /// <para>* ::soundio_input_device_count</para>
        /// <para>* ::soundio_output_device_count</para>
        /// <para>* ::soundio_get_input_device</para>
        /// <para>* ::soundio_get_output_device</para>
        /// <para>* ::soundio_default_input_device_index</para>
        /// <para>* ::soundio_default_output_device_index</para>
        /// <para>Note that if you do not care about learning about updated devices, you</para>
        /// <para>might call this function only once ever and never call</para>
        /// <para>::soundio_wait_events.</para>
        /// </remarks>
        public static void soundio_flush_events(SoundIo soundio)
        {
            var __arg0 = ReferenceEquals(soundio, null) ? global::System.IntPtr.Zero : soundio.__Instance;
            Internal.soundio_flush_events_0(__arg0);
        }

        /// <summary>
        /// <para>This function calls ::soundio_flush_events then blocks until another event</para>
        /// <para>is ready or you call ::soundio_wakeup. Be ready for spurious wakeups.</para>
        /// </summary>
        public static void soundio_wait_events(SoundIo soundio)
        {
            var __arg0 = ReferenceEquals(soundio, null) ? global::System.IntPtr.Zero : soundio.__Instance;
            Internal.soundio_wait_events_0(__arg0);
        }

        /// <summary>
        /// <para>Makes ::soundio_wait_events stop blocking.</para>
        /// </summary>
        public static void soundio_wakeup(SoundIo soundio)
        {
            var __arg0 = ReferenceEquals(soundio, null) ? global::System.IntPtr.Zero : soundio.__Instance;
            Internal.soundio_wakeup_0(__arg0);
        }

        /// <summary>
        /// <para>If necessary you can manually trigger a device rescan. Normally you will</para>
        /// <para>not ever have to call this function, as libsoundio listens to system events</para>
        /// <para>for device changes and responds to them by rescanning devices and preparing</para>
        /// <para>the new device information for you to be atomically replaced when you call</para>
        /// <para>::soundio_flush_events. However you might run into cases where you want to</para>
        /// <para>force trigger a device rescan, for example if an ALSA device has a</para>
        /// <para>SoundIoDevice::probe_error.</para>
        /// </summary>
        /// <remarks>
        /// <para>After you call this you still have to use ::soundio_flush_events or</para>
        /// <para>::soundio_wait_events and then wait for the</para>
        /// <para>SoundIo::on_devices_change callback.</para>
        /// <para>This can be called from any thread context except for</para>
        /// <para>SoundIoOutStream::write_callback and SoundIoInStream::read_callback</para>
        /// </remarks>
        public static void soundio_force_device_scan(SoundIo soundio)
        {
            var __arg0 = ReferenceEquals(soundio, null) ? global::System.IntPtr.Zero : soundio.__Instance;
            Internal.soundio_force_device_scan_0(__arg0);
        }

        /// <summary>
        /// <para>Returns whether the channel count field and each channel id matches in</para>
        /// <para>the supplied channel layouts.</para>
        /// </summary>
        public static bool soundio_channel_layout_equal(SoundIoChannelLayout a, SoundIoChannelLayout b)
        {
            var __arg0 = ReferenceEquals(a, null) ? global::System.IntPtr.Zero : a.__Instance;
            var __arg1 = ReferenceEquals(b, null) ? global::System.IntPtr.Zero : b.__Instance;
            var __ret = Internal.soundio_channel_layout_equal_0(__arg0, __arg1);
            return __ret;
        }

        public static string soundio_get_channel_name(SoundIoChannelId id)
        {
            var __arg0 = id;
            var __ret = Internal.soundio_get_channel_name_0(__arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        /// <para>Given UTF-8 encoded text which is the name of a channel such as</para>
        /// <para>&quot;Front Left&quot;, &quot;FL&quot;, or &quot;front-left&quot;, return the corresponding</para>
        /// <para>SoundIoChannelId. Returns SoundIoChannelIdInvalid for no match.</para>
        /// </summary>
        public static SoundIoChannelId soundio_parse_channel_id(string str, int str_len)
        {
            var __arg0 = Marshal.StringToHGlobalAnsi(str);
            var __ret = Internal.soundio_parse_channel_id_0(__arg0, str_len);
            Marshal.FreeHGlobal(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Returns the number of builtin channel layouts.</para>
        /// </summary>
        public static int soundio_channel_layout_builtin_count()
        {
            var __ret = Internal.soundio_channel_layout_builtin_count_0();
            return __ret;
        }

        /// <summary>
        /// <para>Returns a builtin channel layout. 0 </para>
        /// <para>&lt;</para>
        /// <para>= `index` </para>
        /// <para>&lt;</para>
        /// <para>::soundio_channel_layout_builtin_count</para>
        /// </summary>
        /// <remarks>
        /// <para>Although `index` is of type `int`, it should be a valid</para>
        /// <para>#SoundIoChannelLayoutId enum value.</para>
        /// </remarks>
        public static SoundIoChannelLayout soundio_channel_layout_get_builtin(int index)
        {
            var __ret = Internal.soundio_channel_layout_get_builtin_0(index);
            SoundIoChannelLayout __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (SoundIoChannelLayout.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (SoundIoChannelLayout) SoundIoChannelLayout.NativeToManagedMap[__ret];
            else __result0 = SoundIoChannelLayout.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Get the default builtin channel layout for the given number of channels.</para>
        /// </summary>
        public static SoundIoChannelLayout soundio_channel_layout_get_default(int channel_count)
        {
            var __ret = Internal.soundio_channel_layout_get_default_0(channel_count);
            SoundIoChannelLayout __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (SoundIoChannelLayout.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (SoundIoChannelLayout) SoundIoChannelLayout.NativeToManagedMap[__ret];
            else __result0 = SoundIoChannelLayout.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Return the index of `channel` in `layout`, or `-1` if not found.</para>
        /// </summary>
        public static int soundio_channel_layout_find_channel(SoundIoChannelLayout layout, SoundIoChannelId channel)
        {
            var __arg0 = ReferenceEquals(layout, null) ? global::System.IntPtr.Zero : layout.__Instance;
            var __arg1 = channel;
            var __ret = Internal.soundio_channel_layout_find_channel_0(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Populates the name field of layout if it matches a builtin one.</para>
        /// <para>returns whether it found a match</para>
        /// </summary>
        public static bool soundio_channel_layout_detect_builtin(SoundIoChannelLayout layout)
        {
            var __arg0 = ReferenceEquals(layout, null) ? global::System.IntPtr.Zero : layout.__Instance;
            var __ret = Internal.soundio_channel_layout_detect_builtin_0(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Iterates over preferred_layouts. Returns the first channel layout in</para>
        /// <para>preferred_layouts which matches one of the channel layouts in</para>
        /// <para>available_layouts. Returns NULL if none matches.</para>
        /// </summary>
        public static SoundIoChannelLayout soundio_best_matching_channel_layout(SoundIoChannelLayout preferred_layouts, int preferred_layout_count, SoundIoChannelLayout available_layouts, int available_layout_count)
        {
            var __arg0 = ReferenceEquals(preferred_layouts, null) ? global::System.IntPtr.Zero : preferred_layouts.__Instance;
            var __arg2 = ReferenceEquals(available_layouts, null) ? global::System.IntPtr.Zero : available_layouts.__Instance;
            var __ret = Internal.soundio_best_matching_channel_layout_0(__arg0, preferred_layout_count, __arg2, available_layout_count);
            SoundIoChannelLayout __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (SoundIoChannelLayout.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (SoundIoChannelLayout) SoundIoChannelLayout.NativeToManagedMap[__ret];
            else __result0 = SoundIoChannelLayout.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Sorts by channel count, descending.</para>
        /// </summary>
        public static void soundio_sort_channel_layouts(SoundIoChannelLayout layouts, int layout_count)
        {
            var __arg0 = ReferenceEquals(layouts, null) ? global::System.IntPtr.Zero : layouts.__Instance;
            Internal.soundio_sort_channel_layouts_0(__arg0, layout_count);
        }

        /// <summary>
        /// <para>Returns -1 on invalid format.</para>
        /// </summary>
        public static int soundio_get_bytes_per_sample(SoundIoFormat format)
        {
            var __arg0 = format;
            var __ret = Internal.soundio_get_bytes_per_sample_0(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>A frame is one sample per channel.</para>
        /// </summary>
        public static int soundio_get_bytes_per_frame(SoundIoFormat format, int channel_count)
        {
            var __arg0 = format;
            var __ret = Internal.soundio_get_bytes_per_frame_0(__arg0, channel_count);
            return __ret;
        }

        /// <summary>
        /// <para>Sample rate is the number of frames per second.</para>
        /// </summary>
        public static int soundio_get_bytes_per_second(SoundIoFormat format, int channel_count, int sample_rate)
        {
            var __arg0 = format;
            var __ret = Internal.soundio_get_bytes_per_second_0(__arg0, channel_count, sample_rate);
            return __ret;
        }

        /// <summary>
        /// <para>Returns string representation of `format`.</para>
        /// </summary>
        public static string soundio_format_string(SoundIoFormat format)
        {
            var __arg0 = format;
            var __ret = Internal.soundio_format_string_0(__arg0);
            return Marshal.PtrToStringAnsi(__ret);
        }

        /// <summary>
        /// <para>Get the number of input devices.</para>
        /// <para>Returns -1 if you never called ::soundio_flush_events.</para>
        /// </summary>
        public static int soundio_input_device_count(SoundIo soundio)
        {
            var __arg0 = ReferenceEquals(soundio, null) ? global::System.IntPtr.Zero : soundio.__Instance;
            var __ret = Internal.soundio_input_device_count_0(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Get the number of output devices.</para>
        /// <para>Returns -1 if you never called ::soundio_flush_events.</para>
        /// </summary>
        public static int soundio_output_device_count(SoundIo soundio)
        {
            var __arg0 = ReferenceEquals(soundio, null) ? global::System.IntPtr.Zero : soundio.__Instance;
            var __ret = Internal.soundio_output_device_count_0(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Always returns a device. Call ::soundio_device_unref when done.</para>
        /// <para>`index` must be 0 </para>
        /// <para>&lt;</para>
        /// <para>= index </para>
        /// <para>&lt;</para>
        /// <para>::soundio_input_device_count</para>
        /// <para>Returns NULL if you never called ::soundio_flush_events or if you provide</para>
        /// <para>invalid parameter values.</para>
        /// </summary>
        public static SoundIoDevice soundio_get_input_device(SoundIo soundio, int index)
        {
            var __arg0 = ReferenceEquals(soundio, null) ? global::System.IntPtr.Zero : soundio.__Instance;
            var __ret = Internal.soundio_get_input_device_0(__arg0, index);
            SoundIoDevice __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (SoundIoDevice.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (SoundIoDevice) SoundIoDevice.NativeToManagedMap[__ret];
            else __result0 = SoundIoDevice.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>Always returns a device. Call ::soundio_device_unref when done.</para>
        /// <para>`index` must be 0 </para>
        /// <para>&lt;</para>
        /// <para>= index </para>
        /// <para>&lt;</para>
        /// <para>::soundio_output_device_count</para>
        /// <para>Returns NULL if you never called ::soundio_flush_events or if you provide</para>
        /// <para>invalid parameter values.</para>
        /// </summary>
        public static SoundIoDevice soundio_get_output_device(SoundIo soundio, int index)
        {
            var __arg0 = ReferenceEquals(soundio, null) ? global::System.IntPtr.Zero : soundio.__Instance;
            var __ret = Internal.soundio_get_output_device_0(__arg0, index);
            SoundIoDevice __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (SoundIoDevice.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (SoundIoDevice) SoundIoDevice.NativeToManagedMap[__ret];
            else __result0 = SoundIoDevice.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>returns the index of the default input device</para>
        /// <para>returns -1 if there are no devices or if you never called</para>
        /// <para>::soundio_flush_events.</para>
        /// </summary>
        public static int soundio_default_input_device_index(SoundIo soundio)
        {
            var __arg0 = ReferenceEquals(soundio, null) ? global::System.IntPtr.Zero : soundio.__Instance;
            var __ret = Internal.soundio_default_input_device_index_0(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>returns the index of the default output device</para>
        /// <para>returns -1 if there are no devices or if you never called</para>
        /// <para>::soundio_flush_events.</para>
        /// </summary>
        public static int soundio_default_output_device_index(SoundIo soundio)
        {
            var __arg0 = ReferenceEquals(soundio, null) ? global::System.IntPtr.Zero : soundio.__Instance;
            var __ret = Internal.soundio_default_output_device_index_0(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Add 1 to the reference count of `device`.</para>
        /// </summary>
        public static void soundio_device_ref(SoundIoDevice device)
        {
            var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
            Internal.soundio_device_ref_0(__arg0);
        }

        /// <summary>
        /// <para>Remove 1 to the reference count of `device`. Clean up if it was the last</para>
        /// <para>reference.</para>
        /// </summary>
        public static void soundio_device_unref(SoundIoDevice device)
        {
            var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
            Internal.soundio_device_unref_0(__arg0);
        }

        /// <summary>
        /// <para>Return `true` if and only if the devices have the same SoundIoDevice::id,</para>
        /// <para>SoundIoDevice::is_raw, and SoundIoDevice::aim are the same.</para>
        /// </summary>
        public static bool soundio_device_equal(SoundIoDevice a, SoundIoDevice b)
        {
            var __arg0 = ReferenceEquals(a, null) ? global::System.IntPtr.Zero : a.__Instance;
            var __arg1 = ReferenceEquals(b, null) ? global::System.IntPtr.Zero : b.__Instance;
            var __ret = Internal.soundio_device_equal_0(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Sorts channel layouts by channel count, descending.</para>
        /// </summary>
        public static void soundio_device_sort_channel_layouts(SoundIoDevice device)
        {
            var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
            Internal.soundio_device_sort_channel_layouts_0(__arg0);
        }

        /// <summary>
        /// <para>Convenience function. Returns whether `format` is included in the device's</para>
        /// <para>supported formats.</para>
        /// </summary>
        public static bool soundio_device_supports_format(SoundIoDevice device, SoundIoFormat format)
        {
            var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
            var __arg1 = format;
            var __ret = Internal.soundio_device_supports_format_0(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Convenience function. Returns whether `layout` is included in the device's</para>
        /// <para>supported channel layouts.</para>
        /// </summary>
        public static bool soundio_device_supports_layout(SoundIoDevice device, SoundIoChannelLayout layout)
        {
            var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
            var __arg1 = ReferenceEquals(layout, null) ? global::System.IntPtr.Zero : layout.__Instance;
            var __ret = Internal.soundio_device_supports_layout_0(__arg0, __arg1);
            return __ret;
        }

        /// <summary>
        /// <para>Convenience function. Returns whether `sample_rate` is included in the</para>
        /// <para>device's supported sample rates.</para>
        /// </summary>
        public static bool soundio_device_supports_sample_rate(SoundIoDevice device, int sample_rate)
        {
            var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
            var __ret = Internal.soundio_device_supports_sample_rate_0(__arg0, sample_rate);
            return __ret;
        }

        /// <summary>
        /// <para>Convenience function. Returns the available sample rate nearest to</para>
        /// <para>`sample_rate`, rounding up.</para>
        /// </summary>
        public static int soundio_device_nearest_sample_rate(SoundIoDevice device, int sample_rate)
        {
            var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
            var __ret = Internal.soundio_device_nearest_sample_rate_0(__arg0, sample_rate);
            return __ret;
        }

        /// <summary>
        /// <para>Allocates memory and sets defaults. Next you should fill out the struct fields</para>
        /// <para>and then call ::soundio_outstream_open. Sets all fields to defaults.</para>
        /// <para>Returns `NULL` if and only if memory could not be allocated.</para>
        /// <para>See also ::soundio_outstream_destroy</para>
        /// </summary>
        public static SoundIoOutStream soundio_outstream_create(SoundIoDevice device)
        {
            var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
            var __ret = Internal.soundio_outstream_create_0(__arg0);
            SoundIoOutStream __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (SoundIoOutStream.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (SoundIoOutStream) SoundIoOutStream.NativeToManagedMap[__ret];
            else __result0 = SoundIoOutStream.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>You may not call this function from the SoundIoOutStream::write_callback thread context.</para>
        /// </summary>
        public static void soundio_outstream_destroy(SoundIoOutStream outstream)
        {
            var __arg0 = ReferenceEquals(outstream, null) ? global::System.IntPtr.Zero : outstream.__Instance;
            Internal.soundio_outstream_destroy_0(__arg0);
        }

        /// <summary>
        /// <para>After you call this function, SoundIoOutStream::software_latency is set to</para>
        /// <para>the correct value.</para>
        /// </summary>
        /// <remarks>
        /// <para>The next thing to do is call ::soundio_outstream_start.</para>
        /// <para>If this function returns an error, the outstream is in an invalid state and</para>
        /// <para>you must call ::soundio_outstream_destroy on it.</para>
        /// <para>Possible errors:</para>
        /// <para>* #SoundIoErrorInvalid</para>
        /// <para>   * SoundIoDevice::aim is not #SoundIoDeviceAimOutput</para>
        /// <para>   * SoundIoOutStream::format is not valid</para>
        /// <para>   * SoundIoOutStream::channel_count is greater than #SOUNDIO_MAX_CHANNELS</para>
        /// <para>* #SoundIoErrorNoMem</para>
        /// <para>* #SoundIoErrorOpeningDevice</para>
        /// <para>* #SoundIoErrorBackendDisconnected</para>
        /// <para>* #SoundIoErrorSystemResources</para>
        /// <para>* #SoundIoErrorNoSuchClient - when JACK returns `JackNoSuchClient`</para>
        /// <para>* #SoundIoErrorOpeningDevice</para>
        /// <para>* #SoundIoErrorIncompatibleBackend - SoundIoOutStream::channel_count is</para>
        /// <para>   greater than the number of channels the backend can handle.</para>
        /// <para>* #SoundIoErrorIncompatibleDevice - stream parameters requested are not</para>
        /// <para>   compatible with the chosen device.</para>
        /// </remarks>
        public static int soundio_outstream_open(SoundIoOutStream outstream)
        {
            var __arg0 = ReferenceEquals(outstream, null) ? global::System.IntPtr.Zero : outstream.__Instance;
            var __ret = Internal.soundio_outstream_open_0(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>After you call this function, SoundIoOutStream::write_callback will be called.</para>
        /// </summary>
        /// <remarks>
        /// <para>This function might directly call SoundIoOutStream::write_callback.</para>
        /// <para>Possible errors:</para>
        /// <para>* #SoundIoErrorStreaming</para>
        /// <para>* #SoundIoErrorNoMem</para>
        /// <para>* #SoundIoErrorSystemResources</para>
        /// <para>* #SoundIoErrorBackendDisconnected</para>
        /// </remarks>
        public static int soundio_outstream_start(SoundIoOutStream outstream)
        {
            var __arg0 = ReferenceEquals(outstream, null) ? global::System.IntPtr.Zero : outstream.__Instance;
            var __ret = Internal.soundio_outstream_start_0(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Call this function when you are ready to begin writing to the device buffer.</para>
        /// <para>  * `outstream` - (in) The output stream you want to write to.</para>
        /// <para>  * `areas` - (out) The memory addresses you can write data to, one per</para>
        /// <para>    channel. It is OK to modify the pointers if that helps you iterate.</para>
        /// <para>  * `frame_count` - (in/out) Provide the number of frames you want to write.</para>
        /// <para>    Returned will be the number of frames you can actually write, which is</para>
        /// <para>    also the number of frames that will be written when you call</para>
        /// <para>    ::soundio_outstream_end_write. The value returned will always be less</para>
        /// <para>    than or equal to the value provided.</para>
        /// <para>It is your responsibility to call this function exactly as many times as</para>
        /// <para>necessary to meet the `frame_count_min` and `frame_count_max` criteria from</para>
        /// <para>SoundIoOutStream::write_callback.</para>
        /// <para>You must call this function only from the SoundIoOutStream::write_callback thread context.</para>
        /// <para>After calling this function, write data to `areas` and then call</para>
        /// <para>::soundio_outstream_end_write.</para>
        /// <para>If this function returns an error, do not call ::soundio_outstream_end_write.</para>
        /// </summary>
        /// <remarks>
        /// <para>Possible errors:</para>
        /// <para>* #SoundIoErrorInvalid</para>
        /// <para>   * `*frame_count` </para>
        /// <para>&lt;</para>
        /// <para>= 0</para>
        /// <para>   * `*frame_count` </para>
        /// <para>&lt;</para>
        /// <para>`frame_count_min` or `*frame_count` &gt; `frame_count_max`</para>
        /// <para>   * function called too many times without respecting `frame_count_max`</para>
        /// <para>* #SoundIoErrorStreaming</para>
        /// <para>* #SoundIoErrorUnderflow - an underflow caused this call to fail. You might</para>
        /// <para>   also get a SoundIoOutStream::underflow_callback, and you might not get</para>
        /// <para>   this error code when an underflow occurs. Unlike #SoundIoErrorStreaming,</para>
        /// <para>   the outstream is still in a valid state and streaming can continue.</para>
        /// <para>* #SoundIoErrorIncompatibleDevice - in rare cases it might just now</para>
        /// <para>   be discovered that the device uses non-byte-aligned access, in which</para>
        /// <para>   case this error code is returned.</para>
        /// </remarks>
        public static int soundio_outstream_begin_write(SoundIoOutStream outstream, SoundIoChannelArea areas, ref int frame_count)
        {
            var __arg0 = ReferenceEquals(outstream, null) ? global::System.IntPtr.Zero : outstream.__Instance;
            var __arg1 = ReferenceEquals(areas, null) ? global::System.IntPtr.Zero : areas.__Instance;
            fixed (int* __refParamPtr2 = &frame_count)
            {
                var __arg2 = __refParamPtr2;
                var __ret = Internal.soundio_outstream_begin_write_0(__arg0, __arg1, __arg2);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Commits the write that you began with ::soundio_outstream_begin_write.</para>
        /// <para>You must call this function only from the SoundIoOutStream::write_callback thread context.</para>
        /// </summary>
        /// <remarks>
        /// <para>Possible errors:</para>
        /// <para>* #SoundIoErrorStreaming</para>
        /// <para>* #SoundIoErrorUnderflow - an underflow caused this call to fail. You might</para>
        /// <para>   also get a SoundIoOutStream::underflow_callback, and you might not get</para>
        /// <para>   this error code when an underflow occurs. Unlike #SoundIoErrorStreaming,</para>
        /// <para>   the outstream is still in a valid state and streaming can continue.</para>
        /// </remarks>
        public static int soundio_outstream_end_write(SoundIoOutStream outstream)
        {
            var __arg0 = ReferenceEquals(outstream, null) ? global::System.IntPtr.Zero : outstream.__Instance;
            var __ret = Internal.soundio_outstream_end_write_0(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Clears the output stream buffer.</para>
        /// <para>This function can be called from any thread.</para>
        /// <para>This function can be called regardless of whether the outstream is paused</para>
        /// <para>or not.</para>
        /// <para>Some backends do not support clearing the buffer. On these backends this</para>
        /// <para>function will return SoundIoErrorIncompatibleBackend.</para>
        /// <para>Some devices do not support clearing the buffer. On these devices this</para>
        /// <para>function might return SoundIoErrorIncompatibleDevice.</para>
        /// <para>Possible errors:</para>
        /// </summary>
        /// <remarks>
        /// <para>* #SoundIoErrorStreaming</para>
        /// <para>* #SoundIoErrorIncompatibleBackend</para>
        /// <para>* #SoundIoErrorIncompatibleDevice</para>
        /// </remarks>
        public static int soundio_outstream_clear_buffer(SoundIoOutStream outstream)
        {
            var __arg0 = ReferenceEquals(outstream, null) ? global::System.IntPtr.Zero : outstream.__Instance;
            var __ret = Internal.soundio_outstream_clear_buffer_0(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>If the underlying backend and device support pausing, this pauses the</para>
        /// <para>stream. SoundIoOutStream::write_callback may be called a few more times if</para>
        /// <para>the buffer is not full.</para>
        /// <para>Pausing might put the hardware into a low power state which is ideal if your</para>
        /// <para>software is silent for some time.</para>
        /// <para>This function may be called from any thread context, including</para>
        /// <para>SoundIoOutStream::write_callback.</para>
        /// <para>Pausing when already paused or unpausing when already unpaused has no</para>
        /// <para>effect and returns #SoundIoErrorNone.</para>
        /// </summary>
        /// <remarks>
        /// <para>Possible errors:</para>
        /// <para>* #SoundIoErrorBackendDisconnected</para>
        /// <para>* #SoundIoErrorStreaming</para>
        /// <para>* #SoundIoErrorIncompatibleDevice - device does not support</para>
        /// <para>   pausing/unpausing. This error code might not be returned even if the</para>
        /// <para>   device does not support pausing/unpausing.</para>
        /// <para>* #SoundIoErrorIncompatibleBackend - backend does not support</para>
        /// <para>   pausing/unpausing.</para>
        /// <para>* #SoundIoErrorInvalid - outstream not opened and started</para>
        /// </remarks>
        public static int soundio_outstream_pause(SoundIoOutStream outstream, bool pause)
        {
            var __arg0 = ReferenceEquals(outstream, null) ? global::System.IntPtr.Zero : outstream.__Instance;
            var __ret = Internal.soundio_outstream_pause_0(__arg0, pause);
            return __ret;
        }

        /// <summary>
        /// <para>Obtain the total number of seconds that the next frame written after the</para>
        /// <para>last frame written with ::soundio_outstream_end_write will take to become</para>
        /// <para>audible. This includes both software and hardware latency. In other words,</para>
        /// <para>if you call this function directly after calling ::soundio_outstream_end_write,</para>
        /// <para>this gives you the number of seconds that the next frame written will take</para>
        /// <para>to become audible.</para>
        /// </summary>
        /// <remarks>
        /// <para>This function must be called only from within SoundIoOutStream::write_callback.</para>
        /// <para>Possible errors:</para>
        /// <para>* #SoundIoErrorStreaming</para>
        /// </remarks>
        public static int soundio_outstream_get_latency(SoundIoOutStream outstream, ref double out_latency)
        {
            var __arg0 = ReferenceEquals(outstream, null) ? global::System.IntPtr.Zero : outstream.__Instance;
            fixed (double* __refParamPtr1 = &out_latency)
            {
                var __arg1 = __refParamPtr1;
                var __ret = Internal.soundio_outstream_get_latency_0(__arg0, __arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Allocates memory and sets defaults. Next you should fill out the struct fields</para>
        /// <para>and then call ::soundio_instream_open. Sets all fields to defaults.</para>
        /// <para>Returns `NULL` if and only if memory could not be allocated.</para>
        /// <para>See also ::soundio_instream_destroy</para>
        /// </summary>
        public static SoundIoInStream soundio_instream_create(SoundIoDevice device)
        {
            var __arg0 = ReferenceEquals(device, null) ? global::System.IntPtr.Zero : device.__Instance;
            var __ret = Internal.soundio_instream_create_0(__arg0);
            SoundIoInStream __result0;
            if (__ret == IntPtr.Zero) __result0 = null;
            else if (SoundIoInStream.NativeToManagedMap.ContainsKey(__ret))
                __result0 = (SoundIoInStream) SoundIoInStream.NativeToManagedMap[__ret];
            else __result0 = SoundIoInStream.__CreateInstance(__ret);
            return __result0;
        }

        /// <summary>
        /// <para>You may not call this function from SoundIoInStream::read_callback.</para>
        /// </summary>
        public static void soundio_instream_destroy(SoundIoInStream instream)
        {
            var __arg0 = ReferenceEquals(instream, null) ? global::System.IntPtr.Zero : instream.__Instance;
            Internal.soundio_instream_destroy_0(__arg0);
        }

        /// <summary>
        /// <para>After you call this function, SoundIoInStream::software_latency is set to the correct</para>
        /// <para>value.</para>
        /// <para>The next thing to do is call ::soundio_instream_start.</para>
        /// <para>If this function returns an error, the instream is in an invalid state and</para>
        /// <para>you must call ::soundio_instream_destroy on it.</para>
        /// </summary>
        /// <remarks>
        /// <para>Possible errors:</para>
        /// <para>* #SoundIoErrorInvalid</para>
        /// <para>   * device aim is not #SoundIoDeviceAimInput</para>
        /// <para>   * format is not valid</para>
        /// <para>   * requested layout channel count &gt; #SOUNDIO_MAX_CHANNELS</para>
        /// <para>* #SoundIoErrorOpeningDevice</para>
        /// <para>* #SoundIoErrorNoMem</para>
        /// <para>* #SoundIoErrorBackendDisconnected</para>
        /// <para>* #SoundIoErrorSystemResources</para>
        /// <para>* #SoundIoErrorNoSuchClient</para>
        /// <para>* #SoundIoErrorIncompatibleBackend</para>
        /// <para>* #SoundIoErrorIncompatibleDevice</para>
        /// </remarks>
        public static int soundio_instream_open(SoundIoInStream instream)
        {
            var __arg0 = ReferenceEquals(instream, null) ? global::System.IntPtr.Zero : instream.__Instance;
            var __ret = Internal.soundio_instream_open_0(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>After you call this function, SoundIoInStream::read_callback will be called.</para>
        /// </summary>
        /// <remarks>
        /// <para>Possible errors:</para>
        /// <para>* #SoundIoErrorBackendDisconnected</para>
        /// <para>* #SoundIoErrorStreaming</para>
        /// <para>* #SoundIoErrorOpeningDevice</para>
        /// <para>* #SoundIoErrorSystemResources</para>
        /// </remarks>
        public static int soundio_instream_start(SoundIoInStream instream)
        {
            var __arg0 = ReferenceEquals(instream, null) ? global::System.IntPtr.Zero : instream.__Instance;
            var __ret = Internal.soundio_instream_start_0(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Call this function when you are ready to begin reading from the device</para>
        /// <para>buffer.</para>
        /// <para>* `instream` - (in) The input stream you want to read from.</para>
        /// <para>* `areas` - (out) The memory addresses you can read data from. It is OK</para>
        /// <para>   to modify the pointers if that helps you iterate. There might be a &quot;hole&quot;</para>
        /// <para>   in the buffer. To indicate this, `areas` will be `NULL` and `frame_count`</para>
        /// <para>   tells how big the hole is in frames.</para>
        /// <para>* `frame_count` - (in/out) - Provide the number of frames you want to read;</para>
        /// <para>   returns the number of frames you can actually read. The returned value</para>
        /// <para>   will always be less than or equal to the provided value. If the provided</para>
        /// <para>   value is less than `frame_count_min` from SoundIoInStream::read_callback this function</para>
        /// <para>   returns with #SoundIoErrorInvalid.</para>
        /// <para>It is your responsibility to call this function no more and no fewer than the</para>
        /// <para>correct number of times according to the `frame_count_min` and</para>
        /// <para>`frame_count_max` criteria from SoundIoInStream::read_callback.</para>
        /// <para>You must call this function only from the SoundIoInStream::read_callback thread context.</para>
        /// <para>After calling this function, read data from `areas` and then use</para>
        /// <para>::soundio_instream_end_read` to actually remove the data from the buffer</para>
        /// <para>and move the read index forward. ::soundio_instream_end_read should not be</para>
        /// <para>called if the buffer is empty (`frame_count` == 0), but it should be called</para>
        /// <para>if there is a hole.</para>
        /// </summary>
        /// <remarks>
        /// <para>Possible errors:</para>
        /// <para>* #SoundIoErrorInvalid</para>
        /// <para>   * `*frame_count` </para>
        /// <para>&lt;</para>
        /// <para>`frame_count_min` or `*frame_count` &gt; `frame_count_max`</para>
        /// <para>* #SoundIoErrorStreaming</para>
        /// <para>* #SoundIoErrorIncompatibleDevice - in rare cases it might just now</para>
        /// <para>   be discovered that the device uses non-byte-aligned access, in which</para>
        /// <para>   case this error code is returned.</para>
        /// </remarks>
        public static int soundio_instream_begin_read(SoundIoInStream instream, SoundIoChannelArea areas, ref int frame_count)
        {
            var __arg0 = ReferenceEquals(instream, null) ? global::System.IntPtr.Zero : instream.__Instance;
            var __arg1 = ReferenceEquals(areas, null) ? global::System.IntPtr.Zero : areas.__Instance;
            fixed (int* __refParamPtr2 = &frame_count)
            {
                var __arg2 = __refParamPtr2;
                var __ret = Internal.soundio_instream_begin_read_0(__arg0, __arg1, __arg2);
                return __ret;
            }
        }

        /// <summary>
        /// <para>This will drop all of the frames from when you called</para>
        /// <para>::soundio_instream_begin_read.</para>
        /// <para>You must call this function only from the SoundIoInStream::read_callback thread context.</para>
        /// <para>You must call this function only after a successful call to</para>
        /// <para>::soundio_instream_begin_read.</para>
        /// </summary>
        /// <remarks>
        /// <para>Possible errors:</para>
        /// <para>* #SoundIoErrorStreaming</para>
        /// </remarks>
        public static int soundio_instream_end_read(SoundIoInStream instream)
        {
            var __arg0 = ReferenceEquals(instream, null) ? global::System.IntPtr.Zero : instream.__Instance;
            var __ret = Internal.soundio_instream_end_read_0(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>If the underyling device supports pausing, this pauses the stream and</para>
        /// <para>prevents SoundIoInStream::read_callback from being called. Otherwise this returns</para>
        /// <para>#SoundIoErrorIncompatibleDevice.</para>
        /// <para>This function may be called from any thread.</para>
        /// <para>Pausing when already paused or unpausing when already unpaused has no</para>
        /// <para>effect and always returns #SoundIoErrorNone.</para>
        /// </summary>
        /// <remarks>
        /// <para>Possible errors:</para>
        /// <para>* #SoundIoErrorBackendDisconnected</para>
        /// <para>* #SoundIoErrorStreaming</para>
        /// <para>* #SoundIoErrorIncompatibleDevice - device does not support pausing/unpausing</para>
        /// </remarks>
        public static int soundio_instream_pause(SoundIoInStream instream, bool pause)
        {
            var __arg0 = ReferenceEquals(instream, null) ? global::System.IntPtr.Zero : instream.__Instance;
            var __ret = Internal.soundio_instream_pause_0(__arg0, pause);
            return __ret;
        }

        /// <summary>
        /// <para>Obtain the number of seconds that the next frame of sound being</para>
        /// <para>captured will take to arrive in the buffer, plus the amount of time that is</para>
        /// <para>represented in the buffer. This includes both software and hardware latency.</para>
        /// </summary>
        /// <remarks>
        /// <para>This function must be called only from within SoundIoInStream::read_callback.</para>
        /// <para>Possible errors:</para>
        /// <para>* #SoundIoErrorStreaming</para>
        /// </remarks>
        public static int soundio_instream_get_latency(SoundIoInStream instream, ref double out_latency)
        {
            var __arg0 = ReferenceEquals(instream, null) ? global::System.IntPtr.Zero : instream.__Instance;
            fixed (double* __refParamPtr1 = &out_latency)
            {
                var __arg1 = __refParamPtr1;
                var __ret = Internal.soundio_instream_get_latency_0(__arg0, __arg1);
                return __ret;
            }
        }

        public global::System.IntPtr userdata
        {
            get
            {
                return ((Internal*) __Instance)->userdata;
            }

            set
            {
                ((Internal*) __Instance)->userdata = (global::System.IntPtr) value;
            }
        }

        public Action<SoundIo> on_devices_change
        {
            get
            {
                var __ptr0 = ((Internal*) __Instance)->on_devices_change;
                return (Action<SoundIo>)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(Action<SoundIo>));
            }

            set
            {
                ((Internal*) __Instance)->on_devices_change = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public Action<SoundIo, int> on_backend_disconnect
        {
            get
            {
                var __ptr0 = ((Internal*) __Instance)->on_backend_disconnect;
                return (Action<SoundIo, int>)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(Action<SoundIo, int>));
            }

            set
            {
                ((Internal*) __Instance)->on_backend_disconnect = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public Action<SoundIo> on_events_signal
        {
            get
            {
                var __ptr0 = ((Internal*) __Instance)->on_events_signal;
                return (Action<SoundIo>)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(Action<SoundIo>));
            }

            set
            {
                ((Internal*) __Instance)->on_events_signal = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public SoundIoBackend current_backend
        {
            get
            {
                return ((Internal*) __Instance)->current_backend;
            }

            set
            {
                ((Internal*) __Instance)->current_backend = value;
            }
        }

        public string app_name
        {
            get
            {
                return Marshal.PtrToStringAnsi(((Internal*) __Instance)->app_name);
            }

            set
            {
                ((Internal*) __Instance)->app_name = (global::System.IntPtr) Marshal.StringToHGlobalAnsi(value);
            }
        }

        public Action emit_rtprio_warning
        {
            get
            {
                var __ptr0 = ((Internal*) __Instance)->emit_rtprio_warning;
                return (Action)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(Action));
            }

            set
            {
                ((Internal*) __Instance)->emit_rtprio_warning = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public Action<string> jack_info_callback
        {
            get
            {
                var __ptr0 = ((Internal*) __Instance)->jack_info_callback;
                return (Action<string>)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(Action<string>));
            }

            set
            {
                ((Internal*) __Instance)->jack_info_callback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public Action<string> jack_error_callback
        {
            get
            {
                var __ptr0 = ((Internal*) __Instance)->jack_error_callback;
                return (Action<string>)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(Action<string>));
            }

            set
            {
                ((Internal*) __Instance)->jack_error_callback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    /// <summary>
    /// <para>The size of this struct is not part of the API or ABI.</para>
    /// </summary>
    public unsafe partial class SoundIoDevice : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 192)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr soundio;

            [FieldOffset(4)]
            public global::System.IntPtr id;

            [FieldOffset(8)]
            public global::System.IntPtr name;

            [FieldOffset(12)]
            public SoundIoDeviceAim aim;

            [FieldOffset(16)]
            public global::System.IntPtr layouts;

            [FieldOffset(20)]
            public int layout_count;

            [FieldOffset(24)]
            public SoundIoChannelLayout.Internal current_layout;

            [FieldOffset(128)]
            public global::System.IntPtr formats;

            [FieldOffset(132)]
            public int format_count;

            [FieldOffset(136)]
            public SoundIoFormat current_format;

            [FieldOffset(140)]
            public global::System.IntPtr sample_rates;

            [FieldOffset(144)]
            public int sample_rate_count;

            [FieldOffset(148)]
            public int sample_rate_current;

            [FieldOffset(152)]
            public double software_latency_min;

            [FieldOffset(160)]
            public double software_latency_max;

            [FieldOffset(168)]
            public double software_latency_current;

            [FieldOffset(176)]
            public byte is_raw;

            [FieldOffset(180)]
            public int ref_count;

            [FieldOffset(184)]
            public int probe_error;
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SoundIoDevice> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SoundIoDevice>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static SoundIoDevice __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new SoundIoDevice(native.ToPointer(), skipVTables);
        }

        public static SoundIoDevice __CreateInstance(SoundIoDevice.Internal native, bool skipVTables = false)
        {
            return new SoundIoDevice(native, skipVTables);
        }

        private static void* __CopyValue(SoundIoDevice.Internal native)
        {
            var ret = Marshal.AllocHGlobal(192);
            *(SoundIoDevice.Internal*) ret = native;
            return ret.ToPointer();
        }

        private SoundIoDevice(SoundIoDevice.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SoundIoDevice(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            SoundIoDevice __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public SoundIo soundio
        {
            get
            {
                SoundIo __result0;
                if (((Internal*) __Instance)->soundio == IntPtr.Zero) __result0 = null;
                else if (SoundIo.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->soundio))
                    __result0 = (SoundIo) SoundIo.NativeToManagedMap[((Internal*) __Instance)->soundio];
                else __result0 = SoundIo.__CreateInstance(((Internal*) __Instance)->soundio);
                return __result0;
            }

            set
            {
                ((Internal*) __Instance)->soundio = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public sbyte* id
        {
            get
            {
                return ((Internal*) __Instance)->id;
            }

            set
            {
                ((Internal*) __Instance)->id = (global::System.IntPtr) value;
            }
        }

        public sbyte* name
        {
            get
            {
                return ((Internal*) __Instance)->name;
            }

            set
            {
                ((Internal*) __Instance)->name = (global::System.IntPtr) value;
            }
        }

        public SoundIoDeviceAim aim
        {
            get
            {
                return ((Internal*) __Instance)->aim;
            }

            set
            {
                ((Internal*) __Instance)->aim = value;
            }
        }

        public SoundIoChannelLayout layouts
        {
            get
            {
                SoundIoChannelLayout __result0;
                if (((Internal*) __Instance)->layouts == IntPtr.Zero) __result0 = null;
                else if (SoundIoChannelLayout.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->layouts))
                    __result0 = (SoundIoChannelLayout) SoundIoChannelLayout.NativeToManagedMap[((Internal*) __Instance)->layouts];
                else __result0 = SoundIoChannelLayout.__CreateInstance(((Internal*) __Instance)->layouts);
                return __result0;
            }

            set
            {
                ((Internal*) __Instance)->layouts = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public int layout_count
        {
            get
            {
                return ((Internal*) __Instance)->layout_count;
            }

            set
            {
                ((Internal*) __Instance)->layout_count = value;
            }
        }

        public SoundIoChannelLayout current_layout
        {
            get
            {
                return SoundIoChannelLayout.__CreateInstance(((Internal*) __Instance)->current_layout);
            }

            set
            {
                ((Internal*) __Instance)->current_layout = ReferenceEquals(value, null) ? new SoundIoChannelLayout.Internal() : *(SoundIoChannelLayout.Internal*) (value.__Instance);
            }
        }

        public SoundIoFormat* formats
        {
            get
            {
                return ((Internal*) __Instance)->formats;
            }

            set
            {
                ((Internal*) __Instance)->formats = value;
            }
        }

        public int format_count
        {
            get
            {
                return ((Internal*) __Instance)->format_count;
            }

            set
            {
                ((Internal*) __Instance)->format_count = value;
            }
        }

        public SoundIoFormat current_format
        {
            get
            {
                return ((Internal*) __Instance)->current_format;
            }

            set
            {
                ((Internal*) __Instance)->current_format = value;
            }
        }

        public SoundIoSampleRateRange sample_rates
        {
            get
            {
                SoundIoSampleRateRange __result0;
                if (((Internal*) __Instance)->sample_rates == IntPtr.Zero) __result0 = null;
                else if (SoundIoSampleRateRange.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->sample_rates))
                    __result0 = (SoundIoSampleRateRange) SoundIoSampleRateRange.NativeToManagedMap[((Internal*) __Instance)->sample_rates];
                else __result0 = SoundIoSampleRateRange.__CreateInstance(((Internal*) __Instance)->sample_rates);
                return __result0;
            }

            set
            {
                ((Internal*) __Instance)->sample_rates = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public int sample_rate_count
        {
            get
            {
                return ((Internal*) __Instance)->sample_rate_count;
            }

            set
            {
                ((Internal*) __Instance)->sample_rate_count = value;
            }
        }

        public int sample_rate_current
        {
            get
            {
                return ((Internal*) __Instance)->sample_rate_current;
            }

            set
            {
                ((Internal*) __Instance)->sample_rate_current = value;
            }
        }

        public double software_latency_min
        {
            get
            {
                return ((Internal*) __Instance)->software_latency_min;
            }

            set
            {
                ((Internal*) __Instance)->software_latency_min = value;
            }
        }

        public double software_latency_max
        {
            get
            {
                return ((Internal*) __Instance)->software_latency_max;
            }

            set
            {
                ((Internal*) __Instance)->software_latency_max = value;
            }
        }

        public double software_latency_current
        {
            get
            {
                return ((Internal*) __Instance)->software_latency_current;
            }

            set
            {
                ((Internal*) __Instance)->software_latency_current = value;
            }
        }

        public bool is_raw
        {
            get
            {
                return ((Internal*) __Instance)->is_raw != 0;
            }

            set
            {
                ((Internal*) __Instance)->is_raw = (byte) (value ? 1 : 0);
            }
        }

        public int ref_count
        {
            get
            {
                return ((Internal*) __Instance)->ref_count;
            }

            set
            {
                ((Internal*) __Instance)->ref_count = value;
            }
        }

        public int probe_error
        {
            get
            {
                return ((Internal*) __Instance)->probe_error;
            }

            set
            {
                ((Internal*) __Instance)->probe_error = value;
            }
        }
    }

    /// <summary>
    /// <para>The size of this struct is not part of the API or ABI.</para>
    /// </summary>
    public unsafe partial class SoundIoOutStream : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 168)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr device;

            [FieldOffset(4)]
            public SoundIoFormat format;

            [FieldOffset(8)]
            public int sample_rate;

            [FieldOffset(12)]
            public SoundIoChannelLayout.Internal layout;

            [FieldOffset(120)]
            public double software_latency;

            [FieldOffset(128)]
            public global::System.IntPtr userdata;

            [FieldOffset(132)]
            public global::System.IntPtr write_callback;

            [FieldOffset(136)]
            public global::System.IntPtr underflow_callback;

            [FieldOffset(140)]
            public global::System.IntPtr error_callback;

            [FieldOffset(144)]
            public global::System.IntPtr name;

            [FieldOffset(148)]
            public byte non_terminal_hint;

            [FieldOffset(152)]
            public int bytes_per_frame;

            [FieldOffset(156)]
            public int bytes_per_sample;

            [FieldOffset(160)]
            public int layout_error;
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SoundIoOutStream> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SoundIoOutStream>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static SoundIoOutStream __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new SoundIoOutStream(native.ToPointer(), skipVTables);
        }

        public static SoundIoOutStream __CreateInstance(SoundIoOutStream.Internal native, bool skipVTables = false)
        {
            return new SoundIoOutStream(native, skipVTables);
        }

        private static void* __CopyValue(SoundIoOutStream.Internal native)
        {
            var ret = Marshal.AllocHGlobal(168);
            *(SoundIoOutStream.Internal*) ret = native;
            return ret.ToPointer();
        }

        private SoundIoOutStream(SoundIoOutStream.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SoundIoOutStream(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            SoundIoOutStream __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public SoundIoDevice device
        {
            get
            {
                SoundIoDevice __result0;
                if (((Internal*) __Instance)->device == IntPtr.Zero) __result0 = null;
                else if (SoundIoDevice.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->device))
                    __result0 = (SoundIoDevice) SoundIoDevice.NativeToManagedMap[((Internal*) __Instance)->device];
                else __result0 = SoundIoDevice.__CreateInstance(((Internal*) __Instance)->device);
                return __result0;
            }

            set
            {
                ((Internal*) __Instance)->device = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public SoundIoFormat format
        {
            get
            {
                return ((Internal*) __Instance)->format;
            }

            set
            {
                ((Internal*) __Instance)->format = value;
            }
        }

        public int sample_rate
        {
            get
            {
                return ((Internal*) __Instance)->sample_rate;
            }

            set
            {
                ((Internal*) __Instance)->sample_rate = value;
            }
        }

        public SoundIoChannelLayout layout
        {
            get
            {
                return SoundIoChannelLayout.__CreateInstance(((Internal*) __Instance)->layout);
            }

            set
            {
                ((Internal*) __Instance)->layout = ReferenceEquals(value, null) ? new SoundIoChannelLayout.Internal() : *(SoundIoChannelLayout.Internal*) (value.__Instance);
            }
        }

        public double software_latency
        {
            get
            {
                return ((Internal*) __Instance)->software_latency;
            }

            set
            {
                ((Internal*) __Instance)->software_latency = value;
            }
        }

        public global::System.IntPtr userdata
        {
            get
            {
                return ((Internal*) __Instance)->userdata;
            }

            set
            {
                ((Internal*) __Instance)->userdata = (global::System.IntPtr) value;
            }
        }

        public Action<SoundIoOutStream, int, int> write_callback
        {
            get
            {
                var __ptr0 = ((Internal*) __Instance)->write_callback;
                return (Action<SoundIoOutStream, int, int>)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(Action<SoundIoOutStream, int, int>));
            }

            set
            {
                ((Internal*) __Instance)->write_callback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public Action<SoundIoOutStream> underflow_callback
        {
            get
            {
                var __ptr0 = ((Internal*) __Instance)->underflow_callback;
                return (Action<SoundIoOutStream>)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(Action<SoundIoOutStream>));
            }

            set
            {
                ((Internal*) __Instance)->underflow_callback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public Action<SoundIoOutStream, int> error_callback
        {
            get
            {
                var __ptr0 = ((Internal*) __Instance)->error_callback;
                return (Action<SoundIoOutStream, int>)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(Action<SoundIoOutStream, int>));
            }

            set
            {
                ((Internal*) __Instance)->error_callback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public string name
        {
            get
            {
                return Marshal.PtrToStringAnsi(((Internal*) __Instance)->name);
            }

            set
            {
                ((Internal*) __Instance)->name = (global::System.IntPtr) Marshal.StringToHGlobalAnsi(value);
            }
        }

        public bool non_terminal_hint
        {
            get
            {
                return ((Internal*) __Instance)->non_terminal_hint != 0;
            }

            set
            {
                ((Internal*) __Instance)->non_terminal_hint = (byte) (value ? 1 : 0);
            }
        }

        public int bytes_per_frame
        {
            get
            {
                return ((Internal*) __Instance)->bytes_per_frame;
            }

            set
            {
                ((Internal*) __Instance)->bytes_per_frame = value;
            }
        }

        public int bytes_per_sample
        {
            get
            {
                return ((Internal*) __Instance)->bytes_per_sample;
            }

            set
            {
                ((Internal*) __Instance)->bytes_per_sample = value;
            }
        }

        public int layout_error
        {
            get
            {
                return ((Internal*) __Instance)->layout_error;
            }

            set
            {
                ((Internal*) __Instance)->layout_error = value;
            }
        }
    }

    /// <summary>
    /// <para>The size of this struct is not part of the API or ABI.</para>
    /// </summary>
    public unsafe partial class SoundIoInStream : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 168)]
        public partial struct Internal
        {
            [FieldOffset(0)]
            public global::System.IntPtr device;

            [FieldOffset(4)]
            public SoundIoFormat format;

            [FieldOffset(8)]
            public int sample_rate;

            [FieldOffset(12)]
            public SoundIoChannelLayout.Internal layout;

            [FieldOffset(120)]
            public double software_latency;

            [FieldOffset(128)]
            public global::System.IntPtr userdata;

            [FieldOffset(132)]
            public global::System.IntPtr read_callback;

            [FieldOffset(136)]
            public global::System.IntPtr overflow_callback;

            [FieldOffset(140)]
            public global::System.IntPtr error_callback;

            [FieldOffset(144)]
            public global::System.IntPtr name;

            [FieldOffset(148)]
            public byte non_terminal_hint;

            [FieldOffset(152)]
            public int bytes_per_frame;

            [FieldOffset(156)]
            public int bytes_per_sample;

            [FieldOffset(160)]
            public int layout_error;
        }

        public global::System.IntPtr __Instance { get; protected set; }

        protected int __PointerAdjustment;
        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SoundIoInStream> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SoundIoInStream>();
        protected void*[] __OriginalVTables;

        protected bool __ownsNativeInstance;

        public static SoundIoInStream __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
        {
            return new SoundIoInStream(native.ToPointer(), skipVTables);
        }

        public static SoundIoInStream __CreateInstance(SoundIoInStream.Internal native, bool skipVTables = false)
        {
            return new SoundIoInStream(native, skipVTables);
        }

        private static void* __CopyValue(SoundIoInStream.Internal native)
        {
            var ret = Marshal.AllocHGlobal(168);
            *(SoundIoInStream.Internal*) ret = native;
            return ret.ToPointer();
        }

        private SoundIoInStream(SoundIoInStream.Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected SoundIoInStream(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new global::System.IntPtr(native);
        }

        public void Dispose()
        {
            Dispose(disposing: true);
        }

        protected virtual void Dispose(bool disposing)
        {
            SoundIoInStream __dummy;
            NativeToManagedMap.TryRemove(__Instance, out __dummy);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
        }

        public SoundIoDevice device
        {
            get
            {
                SoundIoDevice __result0;
                if (((Internal*) __Instance)->device == IntPtr.Zero) __result0 = null;
                else if (SoundIoDevice.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->device))
                    __result0 = (SoundIoDevice) SoundIoDevice.NativeToManagedMap[((Internal*) __Instance)->device];
                else __result0 = SoundIoDevice.__CreateInstance(((Internal*) __Instance)->device);
                return __result0;
            }

            set
            {
                ((Internal*) __Instance)->device = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
            }
        }

        public SoundIoFormat format
        {
            get
            {
                return ((Internal*) __Instance)->format;
            }

            set
            {
                ((Internal*) __Instance)->format = value;
            }
        }

        public int sample_rate
        {
            get
            {
                return ((Internal*) __Instance)->sample_rate;
            }

            set
            {
                ((Internal*) __Instance)->sample_rate = value;
            }
        }

        public SoundIoChannelLayout layout
        {
            get
            {
                return SoundIoChannelLayout.__CreateInstance(((Internal*) __Instance)->layout);
            }

            set
            {
                ((Internal*) __Instance)->layout = ReferenceEquals(value, null) ? new SoundIoChannelLayout.Internal() : *(SoundIoChannelLayout.Internal*) (value.__Instance);
            }
        }

        public double software_latency
        {
            get
            {
                return ((Internal*) __Instance)->software_latency;
            }

            set
            {
                ((Internal*) __Instance)->software_latency = value;
            }
        }

        public global::System.IntPtr userdata
        {
            get
            {
                return ((Internal*) __Instance)->userdata;
            }

            set
            {
                ((Internal*) __Instance)->userdata = (global::System.IntPtr) value;
            }
        }

        public Action<SoundIoInStream, int, int> read_callback
        {
            get
            {
                var __ptr0 = ((Internal*) __Instance)->read_callback;
                return (Action<SoundIoInStream, int, int>)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(Action<SoundIoInStream, int, int>));
            }

            set
            {
                ((Internal*) __Instance)->read_callback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public Action<SoundIoInStream> overflow_callback
        {
            get
            {
                var __ptr0 = ((Internal*) __Instance)->overflow_callback;
                return (Action<SoundIoInStream>)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(Action<SoundIoInStream>));
            }

            set
            {
                ((Internal*) __Instance)->overflow_callback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public Action<SoundIoInStream, int> error_callback
        {
            get
            {
                var __ptr0 = ((Internal*) __Instance)->error_callback;
                return (Action<SoundIoInStream, int>)Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(Action<SoundIoInStream, int>));
            }

            set
            {
                ((Internal*) __Instance)->error_callback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public string name
        {
            get
            {
                return Marshal.PtrToStringAnsi(((Internal*) __Instance)->name);
            }

            set
            {
                ((Internal*) __Instance)->name = (global::System.IntPtr) Marshal.StringToHGlobalAnsi(value);
            }
        }

        public bool non_terminal_hint
        {
            get
            {
                return ((Internal*) __Instance)->non_terminal_hint != 0;
            }

            set
            {
                ((Internal*) __Instance)->non_terminal_hint = (byte) (value ? 1 : 0);
            }
        }

        public int bytes_per_frame
        {
            get
            {
                return ((Internal*) __Instance)->bytes_per_frame;
            }

            set
            {
                ((Internal*) __Instance)->bytes_per_frame = value;
            }
        }

        public int bytes_per_sample
        {
            get
            {
                return ((Internal*) __Instance)->bytes_per_sample;
            }

            set
            {
                ((Internal*) __Instance)->bytes_per_sample = value;
            }
        }

        public int layout_error
        {
            get
            {
                return ((Internal*) __Instance)->layout_error;
            }

            set
            {
                ((Internal*) __Instance)->layout_error = value;
            }
        }
    }
}
